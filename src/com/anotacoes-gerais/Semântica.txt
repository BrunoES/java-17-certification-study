---------------

Nestes exemplos abaixo, apenas os métodos loop1 e loop2 apresentam Unrecheable Code:

void loop1() {
    while (0 != 0) {
        System.out.println("inside");
    }
    System.out.println("outside");
}

void loop2() {
    while (0 == 0) {
        System.out.println("inside");
    }
    System.out.println("outside");
}

void loop3() {
    int i = 0;
    while (i != 0) {
        System.out.println("inside");
    }
    System.out.println("outside");
}

void loop4() {
    int i = 0;
    while (i == 0) {
        System.out.println("inside");
    }
    System.out.println("outside");
}

---------------

// Incrementa valor antes de retornar:
int increase(int number) {
    return ++number;
}

// Retorna valor original antes de incrementar:
int increase(int number) {
    return number++;
}

---------------

No Java, toda varíavel é passada por parâmetro na forma de pass-by-value, e não pass-by-reference.

---------------

Se um método é stático, e ele está sendo chamado de forma não estática, para o Java,
é como se ele não existisse em termos de tomada de decisão para sobrecarga de métodos, ou vice versa.

---------------

int num = array[index = 1]++;
int num = ++array[index = 1];

Em ambos os casos acima, o valor incrementado é o elemento do array, e não o 'num';
---------------

O tipo de retorno de um método não faz parte da sua assinatura para considerar um método duplicado no processo de sobrecarga.
    Exemplos:

	int getNumber() {
		return 0;
	}
	
	float getNumber() {
		return 1;
	}
	
	long getNumber() {
		return 1;
	}
	
	String getA() {
		return "";
	}
	
	Exception getA() {
		return "";
	}

----------------

